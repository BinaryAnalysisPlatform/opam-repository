open Printf


type t = {
  objdump  : string option;
  cxxfilt  : string option;
  objdumps : string list;
  cxxfilts : string list;
}

let (/) = Filename.concat

let read_all ch =
  let buf = Buffer.create 16 in
  let rec loop () =
    match input_char ch with
    | ch -> Buffer.add_char buf ch; loop ()
    | exception End_of_file -> String.trim (Buffer.contents buf) in
  loop ()

let split_on_char sep s =
  let r = ref [] in
  let j = ref (String.length s) in
  for i = String.length s - 1 downto 0 do
    if String.get s i = sep then begin
      r := String.sub s (i + 1) (!j - i - 1) :: !r;
      j := i
    end
  done;
  String.sub s 0 !j :: !r

let split ~on str =
  List.map String.trim (split_on_char on str) |>
  List.filter (fun s -> s <> "")

exception Command_failed of Unix.process_status

let process_status_to_string s =
  let open Unix in
  match s with
  | WEXITED i -> sprintf "exit status %d" 1
  | WSTOPPED i -> sprintf "proccess was stopped by signal %d" i
  | WSIGNALED i -> sprintf "proccess was killed by signal %d" i

let exn_to_string = function
  | Command_failed s -> sprintf "%s" (process_status_to_string s)
  | e -> Printexc.to_string e

let cmd fmt =
  let run c =
    try
      let inp = Unix.open_process_in c in
      let res = read_all inp in
      match Unix.close_process_in inp with
      | Unix.WEXITED 0 -> Some res
      | s -> raise (Command_failed s)
    with e ->
      eprintf "command %s failed: %s\n" c (exn_to_string e);
      None in
  ksprintf run fmt

let split_results fmt =
  let run c =
    match cmd "%s" c with
    | None -> []
    | Some s -> split ~on:'\n' s in
  ksprintf run fmt

let string_of_list xs =
  List.fold_left (fun acc x ->
      sprintf "%s\"%s\"; " acc x) "[" xs ^ "]"

let is_none = function
  | None -> true
  | _ -> false

let failed_to_find cmd =
  eprintf "%s not found\n" cmd;
  exit 1

let write {objdump; objdumps; cxxfilt; cxxfilts;} =
  if is_none objdump then failed_to_find "objdump";
  if is_none cxxfilt then failed_to_find "c++filt";
  let digest path = Digest.to_hex (Digest.file path) in
  let depends = function
    | None -> ""
    | Some file ->
      sprintf "[ %S %S ]" file (digest file) in
  let get x = match x with
    | None -> ""
    | Some x -> x in
  let file_depends =
    let deps = String.concat " " [depends objdump; depends cxxfilt] in
    if deps = "" then ""
    else sprintf "file-depends: [ %s ]" deps in
  let oc = open_out "%{_:name}%.config" in
  fprintf oc {|
opam-version: "2.0"
%s
variables {
  cxxfilt: %S
  cxxfilts: %S
  objdump: %S
  objdumps: %S
}
|} file_depends
    (get cxxfilt) (string_of_list cxxfilts)
    (get objdump) (string_of_list objdumps);
  close_out oc

let which name () = cmd "which %s" name

let of_env var () =
  try Some (Sys.getenv var)
  with Not_found -> None

let cellar () = cmd "brew --cellar"

let find_in_cellar name () =
  match cmd "brew --cellar" with
  | None -> None
  | Some cellar ->
    match cmd "find %s/binutils -name %s" cellar name with
    | None -> None
    | Some s -> match split ~on:'\n' s with
      | [] -> None
      | x :: _ -> Some x

let of_opam_config var () = match var with
  | "" -> None
  | x  -> Some x

let rec first_success = function
  | [] -> None
  | f :: fs ->  match f () with
    | None -> first_success fs
    | r -> r

let find_objdump () =
  first_success [
    of_opam_config "%{objdump-path}%";
    of_env "OBJDUMP_PATH";
  ]

let find_cxxfilt () =
  first_success [
    of_opam_config "%{cxxfilt-path}%";
    of_env "CXXFILT_PATH";
  ]

let all_pathes () =
  match of_env "PATH" () with
  | None -> []
  | Some r -> split r ~on:':'

let filter_objdumps objs =
  let has_prefix str pref =
    let len = String.length pref in
    len <= String.length str &&
    String.(sub str 0 len = pref) in
  List.fold_left (fun acc obj ->
      let file = Filename.basename obj in
      if file = "objdump" || file = "gobjdump" || has_prefix file "llvm"
      then acc
      else
      if Filename.check_suffix file "-objdump" then
        Filename.chop_suffix file "-objdump" :: acc
      else acc) [] objs

let has_prefix str pref =
  let len = String.length pref in
  len <= String.length str &&
  String.(sub str 0 len = pref)

let collect t pathes =
  let is_known fullpath = function
    | None -> false
    | Some x -> x = fullpath in
  let is_objdump path file =
    Filename.check_suffix file "objdump" &&
    not (is_known (path/file) t.objdump) &&
    not (has_prefix file "llvm") in
  let is_cxxfilt path file =
    not (is_known (path/file) t.cxxfilt) &&
    Filename.check_suffix file "c++filt" in
  let find t path =
    if Sys.file_exists path && Sys.is_directory path then
      Sys.readdir path |>
      Array.fold_left (fun t file ->
          if is_objdump path file then
            {t with objdumps = path / file :: t.objdumps}
          else if is_cxxfilt path file then
            {t with cxxfilts = path / file :: t.cxxfilts}
          else t) t
    else t in
  List.fold_left find t pathes

let () =
  try
    match "%{os}%" with
    | "linux" ->
      let objdump = first_success [
          find_objdump;
          which "objdump"] in
      let cxxfilt = first_success [
          find_cxxfilt;
          which "c++filt"] in
      let t = collect
          {objdump; cxxfilt; objdumps=[]; cxxfilts=[]}
          (all_pathes ()) in
      write t
    | "macos" ->
      let objdump = first_success [
          find_objdump;
          which "gobjdump";
          find_in_cellar "gobjdump"; ] in
      let cxxfilt = first_success [
          find_cxxfilt;
          which "c++filt";
          find_in_cellar "c++filt"; ] in
      let pathes = match cellar () with
        | None -> all_pathes ()
        | Some cellar -> cellar :: all_pathes () in
      let t = collect
          {objdump; cxxfilt; objdumps=[]; cxxfilts=[]}
          pathes in
      write t
    | s ->
      eprintf "unsupported OS %s\n" s;
      exit 1
  with e ->
    eprintf "build failed: %s\n" (Printexc.to_string e);
    exit 1
