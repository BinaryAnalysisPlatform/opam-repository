open Printf
open StdLabels

type file = {
  path : string;
  dgst : string;
}

type tool = {
  test  : string -> bool;
  main  : file option;
  files : file list;
}

module Digests = Set.Make(String)
module Vars = Map.Make(String)

type t = tool Vars.t

let (/) = Filename.concat

let digest path = Digest.to_hex (Digest.file path)

let read_all ch =
  let buf = Buffer.create 16 in
  let rec loop () =
    match input_char ch with
    | ch -> Buffer.add_char buf ch; loop ()
    | exception End_of_file -> String.trim (Buffer.contents buf) in
  loop ()

let split_on_char sep s =
  let r = ref [] in
  let j = ref (String.length s) in
  for i = String.length s - 1 downto 0 do
    if String.get s i = sep then begin
      r := String.sub s (i + 1) (!j - i - 1) :: !r;
      j := i
    end
  done;
  String.sub s 0 !j :: !r

let split ~on str =
  List.map String.trim (split_on_char on str) |>
  List.filter ~f:(fun s -> s <> "")

exception Command_failed of Unix.process_status

let process_status_to_string s =
  let open Unix in
  match s with
  | WEXITED i -> sprintf "exit status %d" 1
  | WSTOPPED i -> sprintf "proccess was stopped by signal %d" i
  | WSIGNALED i -> sprintf "proccess was killed by signal %d" i

let exn_to_string = function
  | Command_failed s -> sprintf "%s" (process_status_to_string s)
  | e -> Printexc.to_string e

let cmd fmt =
  let run c =
    try
      let inp = Unix.open_process_in c in
      let res = read_all inp in
      match Unix.close_process_in inp with
      | Unix.WEXITED 0 -> Some res
      | s -> raise (Command_failed s)
    with e ->
      eprintf "command %s failed: %s\n" c (exn_to_string e);
      None in
  ksprintf run fmt

let string_of_files xs =
  List.fold_left xs ~f:(fun s {path} ->
      sprintf "%s\"%s\"; " s path) ~init:"[" ^ "]"

let is_none = function
  | None -> true
  | _ -> false

let failed_to_find cmd =
  eprintf "%s not found\n" cmd;
  exit 1

let dedup main files =
  fst @@
  List.fold_left files
    ~init:([], Digests.add main.dgst Digests.empty)
    ~f:(fun ((files, digests) as acc) ({dgst} as file) ->
        if Digests.mem dgst digests
        then acc
        else file :: files, Digests.add dgst digests)

let dependencies ~init files =
  List.fold_left files ~init ~f:(fun depends {path; dgst} ->
      sprintf " [ %S %S ] " path dgst :: depends)

let write t =
  let deps, vars =
    Vars.fold (fun name {main; files} (deps, vars) ->
        let main, files = match main, files with
          | None, [] -> failed_to_find name
          | None, main :: files -> main, files
          | Some main, files -> main, files in
        let files = dedup main files in
        let deps = dependencies ~init:deps (main :: files) in
        let main = sprintf "%s: %S" name main.path in
        let files = sprintf "%ss: %S" name (string_of_files files) in
        deps, main :: files :: vars) t ([], [])  in
  let oc = open_out "%{_:name}%.config" in
  let deps = String.concat "\n" deps in
  let vars = String.concat "\n" vars in
  fprintf oc {|
opam-version: "2.0"
file-depends: [ %s ]
variables {
%s
}
|} deps vars;
  close_out oc

let of_env var () =
  try Some (Sys.getenv var)
  with Not_found -> None

let of_opam_config var () = match var with
  | "" -> None
  | x  -> Some x

let match_files path files test =
  Array.fold_left files ~init:[] ~f:(fun acc file ->
      if test file then
        let path = path / file in
        {path; dgst = digest path} :: acc
      else acc)

let update t path  =
  if Sys.is_directory path then
    let files = Sys.readdir path in
    Vars.fold (fun name tool t ->
        let files = match_files path files tool.test in
        Vars.add name {tool with files = tool.files @ files} t) t t
  else t

let collect t pathes = List.fold_left pathes ~f:update ~init:t

let search t path =
  let rec loop t path =
    if Sys.is_directory path
    then
      Sys.readdir path |>
      Array.fold_left ~init:t ~f:(fun t file -> loop t @@ path / file)
    else
      Vars.fold (fun name tool t ->
          if tool.test (Filename.basename path)
          then
            let file = {path; dgst = digest path} in
            Vars.add name {tool with files = tool.files @ [file]} t
          else t) t t in
  loop t path

let rec first_success = function
  | [] -> None
  | f :: fs ->  match f () with
    | None -> first_success fs
    | r -> r

let find_objdump () =
  first_success [
    of_opam_config "%{objdump-path}%";
    of_env "OBJDUMP_PATH";
  ]

let find_cxxfilt () =
  first_success [
    of_opam_config "%{cxxfilt-path}%";
    of_env "CXXFILT_PATH";
  ]

let is_dir p = Sys.file_exists p && Sys.is_directory p

let all_pathes () =
  match of_env "PATH" () with
  | None -> []
  | Some r -> List.filter ~f:is_dir (split r ~on:':')

let has_prefix str pref =
  let len = String.length pref in
  len <= String.length str &&
  String.(sub str 0 len = pref)

let add_var name ~file ~test t =
  let main = match file with
    | None -> None
    | Some path -> Some {path; dgst = digest path }  in
  Vars.add name {test; main; files = []} t

let is_objdump file =
  Filename.check_suffix file "objdump" &&
  not (has_prefix file "llvm")

let is_cxxfilt file = Filename.check_suffix file "c++filt"

let t =
  add_var "objdump"
    ~file:(find_objdump ())
    ~test:is_objdump
    Vars.empty |>
  add_var "cxxfilt"
    ~file:(find_cxxfilt ())
    ~test:is_cxxfilt

let () =
  try
    match "%{os}%" with
    | "linux" -> write @@ collect t @@ all_pathes ()
    | "macos" ->
      let t = match cmd "brew --cellar" with
        | None -> t
        | Some cellar -> search t cellar in
      write @@ collect t @@ all_pathes ()
    | s ->
      eprintf "unsupported OS %s\n" s;
      exit 1
  with e ->
    eprintf "build failed: %s\n" (Printexc.to_string e);
    exit 1
